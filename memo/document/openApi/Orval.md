# Orval 質問・振り返りまとめ（詳細版）

## 1. Orval の概念

- OpenAPI 定義から「API呼び出し関数・型・React Query Hook」を自動生成するツール。
- 主に以下を自動化:
  - axios を用いた API リクエスト関数
  - React Query の useQuery / useMutation Hook
  - queryKey の自動生成・管理
  - 型安全なパラメータ・レスポンス

- 生成コードは「画面単位での API 利用」を想定
- 従来の手書き Hook (`useInitialQuery`) は原則不要

### 1-1. 一言でいうと

**OpenAPI 定義から「API呼び出し関数・型・React Query Hook」を自動生成するツール**。

---

### 1-2. orval が解決する課題

導入前によくある問題：

- API Path を文字列で直書きしている
- axios / useQuery / queryKey を毎回手書き
- 型定義が API 仕様とズレる
- queryKey の管理が属人化する

👉 **OpenAPI を正としてコードを自動生成することで、これらを根本から解消**

---

## 2. 全体アーキテクチャ（責務分離）

```
OpenAPI
  ├─ tag           → ファイル単位
  ├─ operationId   → 関数名 / Hook 名
  └─ schema        → 型定義

orval
  ├─ API関数
  ├─ useQuery / useMutation
  ├─ queryKey
  └─ 型

axios.ts
  └─ interceptor / 共通エラーハンドリング
```

---

## 3. OpenAPI 各要素の役割

### 3-1. tag

- API の分類単位
- `mode: tags` の場合 **ファイル名になる**

```
tags:
  - kkg-08132-reportgroup-master-toroku-resource
```

---

### 3-2. operationId（最重要）

**API を一意に識別する ID**

orval では以下の起点になる：

- API 関数名（例：`init()`）
- React Query Hook 名（`useInit()`）
- queryKey
- 型名

👉 **設計対象・命名ルール必須**

推奨：

- 動詞 + 対象
- 画面名ではなく API の責務

例：

```
getReportGroupMasterInit
createReportGroupMaster
deleteReportGroupMaster
```

---

### 3-3. summary

- API 一覧表示用の短文
- 1行で「何をする API か」
- 日本語で OK

```
summary: レポートグループ初期取得
```

---

### 3-4. description

- 詳細説明用（Markdown 可）
- 業務ルール・注意点を書く場所

必須ではないが、以下の場合は有用：

- 権限条件がある
- 暗黙仕様がある
- パラメータ制約がある

summary と同じ内容しか無いなら **省略可**

---

## 4. orval が生成するもの

### 4-1. API 関数

```ts
init(params, signal);
```

- axios を直接呼ばない
- mutator 経由で API 実行

---

### 4-2. React Query Hook

```ts
useInit(params, options);
useToroku(options);
useSakujo(options);
```

- useQuery / useMutation をラップ
- 型安全

---

### 4-3. getXxxQueryKey

```ts
getInitQueryKey(params);
```

**invalidateQueries 用の queryKey 再現関数**

```ts
queryClient.invalidateQueries({
  queryKey: getInitQueryKey(params),
});
```

---

## 5. axios.ts と mutator の考え方

### 5-1. axiosInstance

- axios.create した実体
- interceptor を管理

### 5-2. apiClient（mutator）

- orval が呼び出す関数
- AxiosResponse を返す

```ts
export const apiClient = <T = unknown>(
  config: AxiosRequestConfig
): Promise<AxiosResponse<T>> => {
  return axiosInstance.request<T>(config);
};
```

命名の意味：

- axiosInstance = 実体
- apiClient = orval の入口

---

## 6. interceptor の return ルール

### 成功時

```ts
return response;
```

### エラー時

```ts
return Promise.reject(error);
```

👉 **常に reject することで React Query にエラーが伝播する**

---

## 7. 既存コードとの整理

### 自作 useInitialQuery

```ts
useInitialQuery(apiPath, queryKey);
```

orval 導入後：

- 原則不要
- orval Hook に置き換える

例：

```ts
useInit(params, {
  query: {
    retry: false,
    refetchOnWindowFocus: false,
  },
});
```

---

## 8. package.json 設定

```json
"scripts": {
  "orval": "orval"
}
```

```bash
npm run orval
```

---

## 9. 運用時の指針（重要）

- OpenAPI が正
- フロントは生成物を使うだけ
- queryKey を手書きしない
- axios を直接呼ばない
- operationId 命名に時間をかける

---

## 10. まとめ

- orval = API 契約からフロント実装を自動生成
- operationId が全ての起点
- axios / React Query の責務が明確になる
- 手書きコードが減り、保守性が上がる

**orval は「導入して終わり」ではなく「API 設計を意識させるツール」**

## 1. Orval の概念

説明済み

## 2. 導入手順

1. インストール

```bash
npm install -D orval
```

2. 設定ファイル作成（`orval.config.ts`）

```ts
import { defineConfig } from "orval";
export default defineConfig({
  api: {
    input: "./api-spec.json",
    output: {
      target: "./openApi/autoGenerated",
      client: "react-query",
      mode: "tags",
      override: {
        query: { useQuery: true, useMutation: true },
        mutator: { path: "./lib/axios.ts", name: "apiClient" },
      },
    },
  },
});
```

3. package.json に scripts 追加

```json
"scripts": {
  "orval": "orval"
}
```

4. 実行

```bash
npm run orval
```

## 3. axios と mutator の関係

- `axiosInstance`: 共通設定（baseURL, withCredentials）や interceptor を持つ「実体」
- `apiClient`: orval が呼ぶ関数。axiosInstance を内部で利用
- 返却型は `Promise<AxiosResponse<T>>` が推奨
- 命名は逆でも動くが、責務を分ける今の命名が推奨
- interceptor でのエラーハンドリング、ログ出力、リダイレクト処理は axiosInstance 側で管理

## 4. 生成された Hook の使い方

### useQuery (例: useInit)

```ts
const { data, isFetching, refetch, queryKey } = useInit(
  params,
  { query: { enabled: true, staleTime: 5000 } },
  queryClient
);
```

- queryKey は自動生成される (`getInitQueryKey`)。
- options で `enabled` や `staleTime`、`initialData` を調整可能。
- mutation 後のデータ更新は `queryClient.invalidateQueries(getInitQueryKey(params))` で管理

### useMutation (例: useToroku, useSakujo)

```ts
const mutation = useToroku({
  mutation: {
    onSuccess: () => queryClient.invalidateQueries(getInitQueryKey(params)),
  },
});
```

- mutationKey は自動生成される
- options で onSuccess, onError などの挙動をカスタマイズ可能

## 5. OpenAPI における summary / description / operationId

### summary

- API の一覧表示用の短い説明（1行）
- Swagger UI やドキュメント左ペインに表示される
- Hook 名の元にならないが、簡単に API の目的を伝える

### description

- 詳細な API 説明、業務ルール、注意点を記述
- 複数行、Markdown 可
- summary と重複するだけなら省略可
- 書くとチームメンバーやフロントエンド側が利用しやすくなる

### operationId

- Hook 名や関数名の元になる一意の識別子
- 画面単位ではなく API 単位で設計される
- 画面側で useInit / useToroku のように呼び出す際の基準

## 6. description / summary の活用方針

- summary: **必須**、短く1行で何をする API か示す
- description: **補足がある場合のみ記載**
  - 部分一致検索の挙動、権限制御、パラメータ制約など
  - 書かない場合は summary の情報だけで十分

- チーム運用ルールとして「summary = 見出し」「description = 本文」と区別すると理解しやすい

## 7. 振り返りポイント

- 自作 Hook は orval Hook に置き換え可能
- axios interceptor と orval mutator は分離して管理
- queryKey は自動生成されるので、画面設計に合わせて作る必要はない
- operationId / tag 名で Hook 名が決まるので、必要に応じて OpenAPI を修正して命名を統一
- description は必要な場合のみ記載
- package.json の scripts で `npm run orval` を管理可能
- React Query の options を調整することで画面ごとの細かい挙動を制御可能

# 仮想化技術と実行環境の時系列まとめ

## 目次

- [1. 物理サーバ時代（〜2000年代前半）](#1-物理サーバ時代2000年代前半)
- [2. 仮想化（VMware中心、2000年代〜2010年代前半）](#2-仮想化vmware中心2000年代2010年代前半)
- [3. クラウド（IaaS: AWS EC2, 2010年代〜現在）](#3-クラウドiaas-aws-ec2-2010年代現在)
- [4. コンテナ時代（CaaS: Docker, Kubernetes, 2015年〜現在）](#4-コンテナ時代caas-docker-kubernetes-2015年現在)
- [5. サーバレス（FaaS: AWS Lambda, 2016年〜現在）](#5-サーバレスfaas-aws-lambda-2016年現在)
- [現在の主な選択肢](#現在の主な選択肢)
  - [IaaS (Infrastructure as a Service) - アイアース](#iaas-infrastructure-as-a-service---アイアース)
  - [CaaS (Container as a Service) - シーアース](#caas-container-as-a-service---シーアース)
  - [FaaS (Function as a Service) - エフアース](#faas-function-as-a-service---エフアース)
  - [PaaS (Platform as a Service) - パース](#paas-platform-as-a-service---パース)
- [主な選択肢を選ぶ基準](#主な選択肢を選ぶ基準)
  - [IaaSを選ぶべきとき](#iaasを選ぶべきとき)
  - [CaaSを選ぶべきとき](#caasを選ぶべきとき)
  - [FaaSを選ぶべきとき](#faasを選ぶべきとき)
  - [PaaSを選ぶべきとき](#paasを選ぶべきとき)
- [選択基準（最低限）](#選択基準最低限)
- [まとめ](#まとめ)

---

## 1. 物理サーバ時代（〜2000年代前半）

### 特徴

- サーバ1台 = OS1つ = アプリ1つ

### 課題

- サーバが増えるとコスト・管理が大きい
- リソースの無駄が多い

---

## 2. 仮想化（VMware中心、2000年代〜2010年代前半）

### 代表技術

- VMware ESXi / vSphere

### 特徴

- 1台の物理サーバに複数の仮想マシンを立てられる

### メリット

- サーバ集約
- リソース効率化
- 運用しやすい

### 課題

- オンプレ運用が前提
- ハード維持コストや拡張性に限界

---

## 3. クラウド（IaaS: AWS EC2, 2010年代〜現在）

### 代表技術

- AWS EC2 / S3 / RDS など

### 特徴

- サーバやストレージを「借りる」形で利用可能

### メリット

- 初期投資ゼロ
- 柔軟なスケーリング
- 従量課金

### 課題

- 仮想マシン単位の管理は残る（OSアップデート、冗長化など）

---

## 4. コンテナ時代（CaaS: Docker, Kubernetes, 2015年〜現在）

### 代表技術

- Docker / Kubernetes / AWS ECS / EKS

### 特徴

- OSを仮想化せず、アプリ実行環境をパッケージ化

### メリット

- 軽量・高速デプロイ
- 環境差異の吸収
- マイクロサービスに最適

### 課題

- オーケストレーション（Kubernetesなど）の学習コスト

---

## 5. サーバレス（FaaS: AWS Lambda, 2016年〜現在）

### 代表技術

- AWS Lambda / Azure Functions / GCP Cloud Functions

### 特徴

- サーバを意識せず「コード単位」で実行

### メリット

- インフラ管理不要
- イベント駆動でコスト効率良い

### 課題

- 長時間処理や特殊環境には不向き
- ベンダーロックイン強め

---

## 現在の主な選択肢

### IaaS (Infrastructure as a Service) - アイアース

**代表例:** EC2, GCE, Azure VM

- **特徴:** 自由度高いが運用負担も大きい
- **適用:** 既存のオンプレ移行やレガシーアプリに強い

### CaaS (Container as a Service) - シーアース

**代表例:** ECS, EKS, AKS, GKE

- **特徴:** コンテナベース。開発〜本番まで環境統一しやすい
- **適用:** マイクロサービス・スケールアウトに最適

### FaaS (Function as a Service) - エフアース

**代表例:** Lambda, Functions

- **特徴:** 小さな処理やイベントドリブンに最適
- **適用:** サーバ管理不要でコスト効率良い

### PaaS (Platform as a Service) - パース

**代表例:** Heroku, Vercel, Firebase, AWS AppRunner

- **特徴:** デプロイの容易さ重視
- **適用:** 学習コスト低いが制約は多め

---

## 主な選択肢を選ぶ基準

### IaaSを選ぶべきとき

- **既存システムの移行** - オンプレミスからクラウドへの移行
- **レガシーアプリケーション** - コンテナ化が困難な古いシステム
- **高いカスタマイズ性が必要** - 特殊な設定や要件がある場合
- **インフラエンジニアがいる** - サーバ管理スキルを持ったチームがある

### CaaSを選ぶべきとき

- **マイクロサービスアーキテクチャ** - 複数の小さなサービスで構成
- **開発・本番環境の統一** - 同じ環境で開発から運用まで行いたい
- **スケールアウトが重要** - 負荷に応じて自動的にスケールしたい
- **DevOps文化がある** - コンテナ技術に習熟したチームがある

### FaaSを選ぶべきとき

- **イベント駆動の処理** - API呼び出し、ファイルアップロード時の処理
- **バッチ処理** - 定期的なデータ処理やレポート生成
- **低コスト重視** - 使用量に応じた従量課金を希望
- **インフラ管理を避けたい** - サーバ管理の負担を最小限にしたい

### PaaSを選ぶべきとき

- **迅速な開発・デプロイ** - プロトタイプやMVPの開発
- **少人数チーム** - インフラ専門知識がない小規模チーム
- **学習コストを抑えたい** - 新しい技術の習得時間を最小限にしたい
- **制約内での開発** - プラットフォームの機能で十分な場合

---

## 選択基準（最低限）

| 項目                 | 説明                                                    |
| -------------------- | ------------------------------------------------------- |
| **運用負担**         | インフラ管理をどこまで自分でやるか                      |
| **スケーラビリティ** | どれくらいの負荷変動を想定するか                        |
| **アプリ形態**       | モノリシック（大きな1つのアプリ）か、マイクロサービスか |
| **コスト**           | 初期コスト・従量課金・学習コストのバランス              |
| **将来性**           | 長期運用を見据えてクラウド・コンテナ対応が進んでいるか  |

---

## まとめ

**時代の流れ**

- **昔:** VMware（オンプレ仮想化）
- **今:** AWS EC2 / コンテナ / サーバレス が主流

プロジェクト規模や運用体制によって **IaaS / CaaS / FaaS / PaaS** を選び分ける、というのが現代の選択肢です。

# HTTPキャッシュの仕様について

## はじめに

SPA開発において、HTTPキャッシュはパフォーマンス向上やサーバー負荷軽減の重要な要素です。本ドキュメントでは、HTTPキャッシュの基本的な概念と実装方法について説明します。

---

## 目次

1. [キャッシュの基本モデル](#キャッシュの基本モデル)
   - [1. Expiration Model（期限切れモデル）](#1-expiration-model期限切れモデル)
   - [2. Validation Model（検証モデル）](#2-validation-model検証モデル)
   - [3. Heuristic Expiration（発見的期限切れ）](#3-heuristic-expiration発見的期限切れ)
2. [現在の使用状況と使い分け](#現在の使用状況と使い分け)
3. [フロントエンド側のふるまい](#フロントエンド側のふるまい)
4. [CDNの影響](#cdnの影響)
5. [API（フロントエンドとバックエンドの通信）での活用](#apiフロントエンドとバックエンドの通信での活用)
6. [ベストプラクティス（SPA開発）](#ベストプラクティスspa開発)
7. [まとめ](#まとめ)

---

## キャッシュの基本モデル

HTTPキャッシュには主に2つのモデルが存在します：

### 1. Expiration Model（期限切れモデル）

**概要：**

- サーバー側で「このリソースはX時間/日まで有効」と明確に期限を指定するモデル
- 指定された期限までは、クライアント（ブラウザやCDN）はキャッシュから直接レスポンスを返す
- 期限が過ぎるまでサーバーへのリクエストを送らない

**HTTPヘッダー：**

- `Cache-Control: max-age=3600` - 秒単位で有効期限を指定
- `Expires: Wed, 21 Oct 2024 07:28:00 GMT` - 具体的な日時を指定（古い方法）

**動作：**

```
クライアント → サーバー（リクエスト）
サーバー → クライアント（レスポンス + Cache-Control: max-age=3600）
↓
1時間以内の再リクエスト → キャッシュから即座に返す（サーバーにはリクエストしない）
1時間経過後 → サーバーに再リクエスト
```

**使用例：**

- 静的ファイル（画像、CSS、JavaScript）
- 変更頻度が低いコンテンツ
- リアルタイム性が重要でないデータ

### 2. Validation Model（検証モデル）

**概要：**

- キャッシュされたリソースが「まだ有効かどうか」をサーバーに確認するモデル
- キャッシュを利用するが、毎回サーバーに検証リクエストを送る
- サーバーが「変更なし」と判断すれば304 Not Modifiedを返し、キャッシュを使う
- 「変更あり」と判断すれば新しいコンテンツを返す

**HTTPヘッダー：**

- `ETag` - リソースのバージョン識別子（ハッシュ値など）
- `Last-Modified` - リソースの最終更新日時
- `If-None-Match` / `If-Modified-Since` - クライアントが送る検証リクエストヘッダー

**動作：**

```
1回目のリクエスト:
クライアント → サーバー
サーバー → クライアント（レスポンス + ETag: "abc123" + Last-Modified: ...）

2回目のリクエスト:
クライアント → サーバー（If-None-Match: "abc123"）
サーバー → クライアント（304 Not Modified / または新しいコンテンツ）
```

**使用例：**

- ユーザー情報、設定など変更される可能性があるデータ
- リアルタイム性が重要なデータ
- APIレスポンス全般

### 3. Heuristic Expiration（発見的期限切れ）

**概要：**

- サーバーが明示的にキャッシュ期限を指定していない場合、ブラウザが独自のルールで期限を推測する
- `Last-Modified`ヘッダーから「（現在時刻 - 最終更新日時）の10%」などを期限として設定する古い手法
- 現在は推奨されていない（予測不可能な動作を引き起こす可能性）

**動作：**

```
サーバー → クライアント（Last-Modified のみ、Cache-Controlなし）
ブラウザ → 「10%ルール」などで自動的に期限を設定
```

**現在の使用状況：**

- 現代のブラウザやCDNでは、明確な`Cache-Control`ヘッダーがない場合の動作が統一されている
- **明示的なキャッシュヘッダーを設定することが強く推奨される**

---

## 現在の使用状況と使い分け

### 現在もよく使われるか？

**はい、現在も非常に重要です。** 特に以下で活用されています：

1. **CDN（Content Delivery Network）** - 世界中のエッジサーバーでキャッシュを活用
2. **ブラウザキャッシュ** - ユーザーのブラウザで静的リソースをキャッシュ
3. **APIレスポンス** - 適切なキャッシュ戦略でサーバー負荷を軽減
4. **SPA（Single Page Application）** - アセットファイルのキャッシュでパフォーマンス向上

### 使い分けのガイドライン

| 用途                        | 推奨モデル                   | Cache-Controlの例              | 理由                                                                   |
| --------------------------- | ---------------------------- | ------------------------------ | ---------------------------------------------------------------------- |
| 静的アセット（JS/CSS/画像） | Expiration Model             | `max-age=31536000, immutable`  | ファイル名にハッシュが含まれるため、変更があれば別ファイルとして扱える |
| ユーザー情報API             | Validation Model             | `max-age=0, must-revalidate`   | データが変更される可能性があり、常に最新を確認したい                   |
| 公開データAPI               | 併用                         | `max-age=300, must-revalidate` | 一定時間はキャッシュし、その後検証                                     |
| HTMLファイル                | Validation Model または なし | `no-cache`                     | SPAの場合、index.htmlは常に最新を取得したい場合が多い                  |

---

## フロントエンド側のふるまい

### ブラウザの動作フロー

```
1. リクエスト送信
   ↓
2. キャッシュチェック
   ├─ キャッシュあり + 有効期限内 → キャッシュから返す（サーバーにはリクエストしない）
   ├─ キャッシュあり + 期限切れ → サーバーに検証リクエスト送信
   │   ├─ 304 Not Modified → キャッシュを使用
   │   └─ 200 OK → 新しいコンテンツを使用してキャッシュ更新
   └─ キャッシュなし → サーバーにリクエスト送信
```

### SPA開発での注意点

1. **APIリクエストのキャッシュ**

   ```javascript
   // fetch APIでは、デフォルトでcacheオプションが'default'
   // 明示的に制御したい場合
   fetch("/api/users", {
     cache: "no-cache", // 常にサーバーにリクエスト
   });

   fetch("/api/users", {
     cache: "default", // ブラウザのキャッシュ動作に従う
   });
   ```

2. **静的アセットのキャッシュ**
   - Webpack/Viteなどでビルド時にファイル名にハッシュを含める
   - `main.abc123.js` → 変更があれば `main.def456.js` になる
   - ブラウザは新しいファイル名として認識し、古いキャッシュと衝突しない

3. **Service Workerとの併用**
   - Service Workerでより細かいキャッシュ制御が可能
   - オフライン対応など、より高度なキャッシュ戦略を実装できる

---

## CDNの影響

### CDNの役割

CDN（Content Delivery Network）は、**キャッシュのレイヤーを追加する**重要な存在です。

```
ユーザー → CDNエッジサーバー → オリジンサーバー
         ↑ ここでもキャッシュが効く
```

### CDNでのキャッシュ動作

1. **初回リクエスト**

   ```
   ユーザー → CDN（キャッシュなし） → オリジンサーバー → CDN（キャッシュ保存） → ユーザー
   ```

2. **2回目以降のリクエスト（キャッシュヒット）**
   ```
   ユーザー → CDN（キャッシュから返す） → ユーザー
   （オリジンサーバーにはリクエストしない）
   ```

### CDN特有の考慮事項

1. **キャッシュキー**
   - 通常：URLのみ
   - 必要に応じて：Cookie、リクエストヘッダーなども含める

2. **Cache-Controlヘッダーの解釈**
   - `public` - CDNでキャッシュ可能
   - `private` - ブラウザのみ、CDNではキャッシュしない
   - `s-maxage` - CDN専用のキャッシュ期限（ブラウザの`max-age`とは別）

3. **キャッシュパージ（Purge）**
   - CDNにキャッシュされたコンテンツを強制的に削除する機能
   - デプロイ後、古いバージョンが配信されないようにするために重要

---

## API（フロントエンドとバックエンドの通信）での活用

### よくある誤解

「API = 常に最新データが必要 = キャッシュは使わない」という考えは**最適ではありません**。

### APIでのキャッシュ活用例

#### 1. 変更頻度が低いデータ

```http
GET /api/products
Cache-Control: max-age=3600, public
```

- 商品リストなど、1時間程度は変更されないデータ

#### 2. ユーザー固有データ（検証モデル推奨）

```http
GET /api/user/profile
Cache-Control: no-cache, must-revalidate
ETag: "user123-v2"
```

- プロフィール情報など、変更される可能性があるが頻繁に変わらないデータ

#### 3. リアルタイム性が重要なデータ

```http
GET /api/notifications
Cache-Control: no-store
```

- 通知など、常に最新である必要があるデータ

### 実装例（Express.js / Node.js）

```javascript
// バックエンド側
app.get("/api/users/:id", (req, res) => {
  const userId = req.params.id;
  const user = getUserFromDB(userId);
  const etag = generateETag(user);

  // クライアントが送ってきたETagと一致するか確認
  if (req.headers["if-none-match"] === etag) {
    return res.status(304).end(); // 変更なし
  }

  res.set({
    ETag: etag,
    "Cache-Control": "max-age=300, must-revalidate",
    "Last-Modified": user.updatedAt.toUTCString(),
  });

  res.json(user);
});
```

---

## ベストプラクティス（SPA開発）

### 1. 静的アセット

```http
Cache-Control: public, max-age=31536000, immutable
```

- ビルドツールでハッシュ付きファイル名を使用
- 長期間キャッシュ可能

### 2. HTMLファイル（index.html）

```http
Cache-Control: no-cache, must-revalidate
```

- SPAの場合、HTML自体は変更されないが、アプリ更新時に最新版を取得したい

### 3. APIレスポンス

- **読み取り専用データ**: `max-age=300` など適切な期間を設定
- **更新可能データ**: `no-cache, must-revalidate` + ETag
- **機密情報**: `private, no-cache`

### 4. デバッグ時の注意

- 開発中はブラウザの開発者ツールで「Disable cache」を有効にする
- 本番環境でも、ネットワークタブでキャッシュの動作を確認する

---

## まとめ

- **Expiration Model**: 明確な期限を設定し、期限までサーバーにリクエストしない
- **Validation Model**: キャッシュを使うが、サーバーに検証リクエストを送る
- **Heuristic Expiration**: 現在は推奨されず、明示的なヘッダー設定を推奨
- **現在も重要**: CDN、ブラウザ、APIのすべてで活用される
- **使い分け**: データの性質（静的/動的、変更頻度、リアルタイム性）に応じて選択
- **SPA開発**: 静的アセットは長期間キャッシュ、APIは検証モデルを中心に活用

適切なキャッシュ戦略により、パフォーマンス向上とサーバー負荷軽減を両立できます。

/**
 * Generated by orval v7.17.2 üç∫
 * Do not edit manually.
 * Order and User Management API
 * Ê≥®Êñá„Å®„É¶„Éº„Ç∂„Éº„ÄÅ‰∏°Êñπ„ÅÆ„É™„ÇΩ„Éº„Çπ„ÇíÁÆ°ÁêÜ„Åô„ÇãAPI„ÄÇ
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ListOrdersParams,
  Order,
  OrderCreateRequest,
  OrderPartialUpdate,
  ValidateOrderParams,
  ValidationResult
} from '../orderAndUserManagementAPI.schemas';

import { apiClient } from '../../../../../../lib/axios';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;





/**
 * @summary Ê≥®Êñá‰∏ÄË¶ß„ÇíÂèñÂæó„Åô„Çã
 */
export const listOrders = (
    params?: ListOrdersParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Order[]>(
      {url: `/orders`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getListOrdersQueryKey = (params?: ListOrdersParams,) => {
    return [
    `/orders`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListOrdersQueryOptions = <TData = Awaited<ReturnType<typeof listOrders>>, TError = unknown>(params?: ListOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOrders>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListOrdersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listOrders>>> = ({ signal }) => listOrders(params, signal);

      

      

   return  { queryKey, queryFn,   retry: false, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listOrders>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ListOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof listOrders>>>
export type ListOrdersQueryError = unknown


export function useListOrders<TData = Awaited<ReturnType<typeof listOrders>>, TError = unknown>(
 params: undefined |  ListOrdersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOrders>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listOrders>>,
          TError,
          Awaited<ReturnType<typeof listOrders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListOrders<TData = Awaited<ReturnType<typeof listOrders>>, TError = unknown>(
 params?: ListOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOrders>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listOrders>>,
          TError,
          Awaited<ReturnType<typeof listOrders>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useListOrders<TData = Awaited<ReturnType<typeof listOrders>>, TError = unknown>(
 params?: ListOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOrders>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ê≥®Êñá‰∏ÄË¶ß„ÇíÂèñÂæó„Åô„Çã
 */

export function useListOrders<TData = Awaited<ReturnType<typeof listOrders>>, TError = unknown>(
 params?: ListOrdersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listOrders>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getListOrdersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary Êñ∞„Åó„ÅÑÊ≥®Êñá„ÇíÁôªÈå≤„Åô„Çã
 */
export const createOrder = (
    orderCreateRequest: OrderCreateRequest,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Order>(
      {url: `/orders`, method: 'POST',
      headers: {'Content-Type': 'application/json', },
      data: orderCreateRequest, signal
    },
      );
    }
  


export const getCreateOrderMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: OrderCreateRequest}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: OrderCreateRequest}, TContext> => {

const mutationKey = ['createOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createOrder>>, {data: OrderCreateRequest}> = (props) => {
          const {data} = props ?? {};

          return  createOrder(data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateOrderMutationResult = NonNullable<Awaited<ReturnType<typeof createOrder>>>
    export type CreateOrderMutationBody = OrderCreateRequest
    export type CreateOrderMutationError = void

    /**
 * @summary Êñ∞„Åó„ÅÑÊ≥®Êñá„ÇíÁôªÈå≤„Åô„Çã
 */
export const useCreateOrder = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createOrder>>, TError,{data: OrderCreateRequest}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createOrder>>,
        TError,
        {data: OrderCreateRequest},
        TContext
      > => {

      const mutationOptions = getCreateOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary ÁâπÂÆö„ÅÆÊ≥®Êñá„ÅÆË©≥Á¥∞„ÇíÂèñÂæó„Åô„Çã
 */
export const getOrderById = (
    orderId: number,
 signal?: AbortSignal
) => {
      
      
      return apiClient<Order>(
      {url: `/orders/${orderId}`, method: 'GET', signal
    },
      );
    }
  



export const getGetOrderByIdQueryKey = (orderId?: number,) => {
    return [
    `/orders/${orderId}`
    ] as const;
    }

    
export const getGetOrderByIdQueryOptions = <TData = Awaited<ReturnType<typeof getOrderById>>, TError = void>(orderId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGetOrderByIdQueryKey(orderId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof getOrderById>>> = ({ signal }) => getOrderById(orderId, signal);

      

      

   return  { queryKey, queryFn, enabled: !!(orderId),  retry: false, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type GetOrderByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getOrderById>>>
export type GetOrderByIdQueryError = void


export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = void>(
 orderId: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = void>(
 orderId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getOrderById>>,
          TError,
          Awaited<ReturnType<typeof getOrderById>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = void>(
 orderId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary ÁâπÂÆö„ÅÆÊ≥®Êñá„ÅÆË©≥Á¥∞„ÇíÂèñÂæó„Åô„Çã
 */

export function useGetOrderById<TData = Awaited<ReturnType<typeof getOrderById>>, TError = void>(
 orderId: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof getOrderById>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getGetOrderByIdQueryOptions(orderId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * @summary ÁâπÂÆö„ÅÆÊ≥®ÊñáÂÖ®‰Ωì„ÇíÂÆåÂÖ®Êõ¥Êñ∞„Åô„Çã
 */
export const replaceOrder = (
    orderId: number,
    order: NonReadonly<Order>,
 ) => {
      
      
      return apiClient<void>(
      {url: `/orders/${orderId}`, method: 'PUT',
      headers: {'Content-Type': 'application/json', },
      data: order
    },
      );
    }
  


export const getReplaceOrderMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replaceOrder>>, TError,{orderId: number;data: NonReadonly<Order>}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof replaceOrder>>, TError,{orderId: number;data: NonReadonly<Order>}, TContext> => {

const mutationKey = ['replaceOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof replaceOrder>>, {orderId: number;data: NonReadonly<Order>}> = (props) => {
          const {orderId,data} = props ?? {};

          return  replaceOrder(orderId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ReplaceOrderMutationResult = NonNullable<Awaited<ReturnType<typeof replaceOrder>>>
    export type ReplaceOrderMutationBody = NonReadonly<Order>
    export type ReplaceOrderMutationError = void

    /**
 * @summary ÁâπÂÆö„ÅÆÊ≥®ÊñáÂÖ®‰Ωì„ÇíÂÆåÂÖ®Êõ¥Êñ∞„Åô„Çã
 */
export const useReplaceOrder = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof replaceOrder>>, TError,{orderId: number;data: NonReadonly<Order>}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof replaceOrder>>,
        TError,
        {orderId: number;data: NonReadonly<Order>},
        TContext
      > => {

      const mutationOptions = getReplaceOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary ÁâπÂÆö„ÅÆÊ≥®Êñá„Éá„Éº„Çø„ÅÆ‰∏ÄÈÉ®„ÅÆ„Åø„ÇíÈÉ®ÂàÜÊõ¥Êñ∞„Åô„Çã
 */
export const updateOrderPartially = (
    orderId: number,
    orderPartialUpdate: OrderPartialUpdate,
 ) => {
      
      
      return apiClient<void>(
      {url: `/orders/${orderId}`, method: 'PATCH',
      headers: {'Content-Type': 'application/json', },
      data: orderPartialUpdate
    },
      );
    }
  


export const getUpdateOrderPartiallyMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderPartially>>, TError,{orderId: number;data: OrderPartialUpdate}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof updateOrderPartially>>, TError,{orderId: number;data: OrderPartialUpdate}, TContext> => {

const mutationKey = ['updateOrderPartially'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateOrderPartially>>, {orderId: number;data: OrderPartialUpdate}> = (props) => {
          const {orderId,data} = props ?? {};

          return  updateOrderPartially(orderId,data,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateOrderPartiallyMutationResult = NonNullable<Awaited<ReturnType<typeof updateOrderPartially>>>
    export type UpdateOrderPartiallyMutationBody = OrderPartialUpdate
    export type UpdateOrderPartiallyMutationError = void

    /**
 * @summary ÁâπÂÆö„ÅÆÊ≥®Êñá„Éá„Éº„Çø„ÅÆ‰∏ÄÈÉ®„ÅÆ„Åø„ÇíÈÉ®ÂàÜÊõ¥Êñ∞„Åô„Çã
 */
export const useUpdateOrderPartially = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateOrderPartially>>, TError,{orderId: number;data: OrderPartialUpdate}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateOrderPartially>>,
        TError,
        {orderId: number;data: OrderPartialUpdate},
        TContext
      > => {

      const mutationOptions = getUpdateOrderPartiallyMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary ÁâπÂÆö„ÅÆÊ≥®Êñá„ÇíÂâäÈô§„Åô„Çã
 */
export const deleteOrder = (
    orderId: number,
 ) => {
      
      
      return apiClient<void>(
      {url: `/orders/${orderId}`, method: 'DELETE'
    },
      );
    }
  


export const getDeleteOrderMutationOptions = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrder>>, TError,{orderId: number}, TContext>, }
): UseMutationOptions<Awaited<ReturnType<typeof deleteOrder>>, TError,{orderId: number}, TContext> => {

const mutationKey = ['deleteOrder'];
const {mutation: mutationOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteOrder>>, {orderId: number}> = (props) => {
          const {orderId} = props ?? {};

          return  deleteOrder(orderId,)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteOrderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteOrder>>>
    
    export type DeleteOrderMutationError = void

    /**
 * @summary ÁâπÂÆö„ÅÆÊ≥®Êñá„ÇíÂâäÈô§„Åô„Çã
 */
export const useDeleteOrder = <TError = void,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteOrder>>, TError,{orderId: number}, TContext>, }
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteOrder>>,
        TError,
        {orderId: number},
        TContext
      > => {

      const mutationOptions = getDeleteOrderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * @summary Ê≥®Êñá„Éá„Éº„Çø„ÅÆÂ¶•ÂΩìÊÄß„Çí‰∫ãÂâç„Å´„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã (ÈùûCRUDÊìç‰Ωú: GET)
 */
export const validateOrder = (
    params: ValidateOrderParams,
 signal?: AbortSignal
) => {
      
      
      return apiClient<ValidationResult>(
      {url: `/orders/validate`, method: 'GET',
        params, signal
    },
      );
    }
  



export const getValidateOrderQueryKey = (params?: ValidateOrderParams,) => {
    return [
    `/orders/validate`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getValidateOrderQueryOptions = <TData = Awaited<ReturnType<typeof validateOrder>>, TError = unknown>(params: ValidateOrderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateOrder>>, TError, TData>>, }
) => {

const {query: queryOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getValidateOrderQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof validateOrder>>> = ({ signal }) => validateOrder(params, signal);

      

      

   return  { queryKey, queryFn,   retry: false, refetchOnWindowFocus: false,  ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof validateOrder>>, TError, TData> & { queryKey: DataTag<QueryKey, TData> }
}

export type ValidateOrderQueryResult = NonNullable<Awaited<ReturnType<typeof validateOrder>>>
export type ValidateOrderQueryError = unknown


export function useValidateOrder<TData = Awaited<ReturnType<typeof validateOrder>>, TError = unknown>(
 params: ValidateOrderParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateOrder>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateOrder>>,
          TError,
          Awaited<ReturnType<typeof validateOrder>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useValidateOrder<TData = Awaited<ReturnType<typeof validateOrder>>, TError = unknown>(
 params: ValidateOrderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateOrder>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof validateOrder>>,
          TError,
          Awaited<ReturnType<typeof validateOrder>>
        > , 'initialData'
      >, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
export function useValidateOrder<TData = Awaited<ReturnType<typeof validateOrder>>, TError = unknown>(
 params: ValidateOrderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateOrder>>, TError, TData>>, }
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> }
/**
 * @summary Ê≥®Êñá„Éá„Éº„Çø„ÅÆÂ¶•ÂΩìÊÄß„Çí‰∫ãÂâç„Å´„ÉÅ„Çß„ÉÉ„ÇØ„Åô„Çã (ÈùûCRUDÊìç‰Ωú: GET)
 */

export function useValidateOrder<TData = Awaited<ReturnType<typeof validateOrder>>, TError = unknown>(
 params: ValidateOrderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof validateOrder>>, TError, TData>>, }
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> } {

  const queryOptions = getValidateOrderQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





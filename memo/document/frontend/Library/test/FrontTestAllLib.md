# フロントエンドテスト戦略まとめ

## 前提構成

- Next.js（App Router）
- TypeScript
- axios（共通設定・interceptor）
- orval（OpenAPI から API / hook 自動生成）
- TanStack Query（データ取得・キャッシュ）
- Jest / React Testing Library
- MSW
- Playwright

---

## テスト設計の大原則

> **テストするのは「自分が責任を持って書いた分岐」だけ**

- ライブラリの内部挙動 → テストしない
- 自動生成コード → テストしない
- 業務ルール・画面分岐 → テストする

---

## レイヤ別の責務とテスト方針

### utils（業務ロジック・変換処理）

**責務**

- 「〇〇の場合は〇〇」
- パラメータ生成
- 業務ルール分岐

**テスト**

- Jest
- 入力 → 出力の純粋関数テスト

---

### axios.ts（共通 HTTP 設定）

**責務**

- header 付与
- interceptor
- 共通エラーハンドリング

**テスト**

- Jest + axios mock
- 401 処理など重要分岐のみ

---

### orval（自動生成 API / hook）

**責務**

- OpenAPI 準拠
- 型安全な API / hook 提供

**テスト**

- 原則不要
- 壊れたら再生成

---

### TanStack Query hook（orval 生成）

**基本方針**

- hook 自体はテストしない
- `data` / `error` が入るかは見ない

#### テスト価値が出るケース

1. **追加オプションを使っている場合**
   - `enabled`
   - `retry`
   - `staleTime`

2. **取得後の独自分岐がある場合**
   - データ内容による表示制御
   - ボタン活性 / 非活性

3. **エラーの業務分岐がある場合**
   - 400 → 画面内メッセージ
   - 401 → 遷移

**テスト方法**

- MSW + RTL（結合テスト）

---

### Component（UI 単体）

**責務**

- 表示
- ユーザー操作

**テスト**

- React Testing Library

---

### API 分岐（200 / 400 / 500）

**主戦場**

- MSW + RTL

**特徴**

- axios / orval / TanStack Query は本物
- HTTP レスポンスだけを偽装

**確認観点**

- 200：正常表示
- 400：業務エラー表示
- 401：認証処理
- 500：汎用エラー

---

### page.tsx（App Router）

**責務**

- 画面構成
- データ受け渡し

**テスト**

- Jest では原則行わない
- ロジックを持たせない

---

### Playwright（E2E）

**目的**

- 画面として壊れていないこと
- 一連のフロー確認

**方針**

- ハッピーパス
- 代表的なエラーのみ

---

### route.ts（API 実装）

**役割**

- 実 API / 疑似バックエンド

**テスト用途**

- Playwright 用
- ローカル E2E

**注意点**

- Jest / RTL の分岐網羅には向かない

---

## テスト全体マップ

```
[ utils ]        → Jest（分岐100%）
[ axios.ts ]     → Jest（必要最小限）
[ orval ]        → テストしない
[ query hook ]   → 原則しない
[ 画面 + API ]   → MSW + RTL（分岐主戦場）
[ page.tsx ]     → Playwright
```

---

## 重要な一文まとめ

> **hookの中身は信頼する**
> **hookの使い方はテストする**

---

## 判断指針（迷ったら）

- 自分で if / 分岐を書いた？ → テストする
- ライブラリの仕様？ → テストしない
- 処理詳細シートに書いてある？ → テスト観点

---

## このまとめの使い方

- 設計レビュー時の指針
- テスト観点洗い出し
- 新規画面作成時のテンプレ

# 目的

本ドキュメントは、**CORS エラー発生の背景・原因・解決策**を、
**フロントエンド視点を主軸に、次にバックエンド視点**で整理し、
将来の構成判断・設計レビュー時に迷わないための振り返り用まとめである。

---

# 1. 前提状況（今回のケース）

- フロントエンド：Next.js（App Router）
- バックエンド：Spring Boot
- ローカル開発中は `route.ts` を API として使用していた
- フェーズが進み、**別環境に置かれたバックエンド API を直接 fetch** する必要が出た
- ブラウザから直接 URL を叩くと成功するが、
  フロントから fetch / axios 経由だと **CORS エラー** が発生

---

# 2. フロントエンド視点での理解（最重要）

## 2.0 同一オリジンとは何か（超重要概念）

### 同一オリジンの定義

**同一オリジン = 以下 3 要素がすべて一致していること**

```
① スキーム（http / https）
② ホスト（ドメイン or IP）
③ ポート番号
```

この 3 つのうち **1 つでも異なれば別オリジン** となる。

---

### 同一オリジン判定の具体例

| フロント                                       | API                                                    | 判定         |
| ---------------------------------------------- | ------------------------------------------------------ | ------------ |
| [http://localhost:3000](http://localhost:3000) | [http://localhost:3000/api](http://localhost:3000/api) | 同一オリジン |
| [http://localhost:3000](http://localhost:3000) | [http://localhost:8080/api](http://localhost:8080/api) | 別オリジン   |
| [http://example.com](http://example.com)       | [http://example.com/api](http://example.com/api)       | 同一オリジン |
| [https://example.com](https://example.com)     | [http://example.com/api](http://example.com/api)       | 別オリジン   |

---

### なぜブラウザは同一オリジンを要求するのか

- Cookie / Authorization ヘッダの漏洩防止
- 悪意あるサイトからの勝手な API 呼び出し防止
- **ブラウザがユーザーを守るための仕様**

※ curl / Postman / サーバ間通信ではこの制限は存在しない。

---

### 同一オリジンと CORS の関係

- 同一オリジン
  - CORS は **存在しない**
  - すべてのリクエストが自然に通る

- 別オリジン
  - ブラウザが CORS チェックを開始
  - サーバが許可ヘッダを返さないと通信不可

👉 **CORS は「別オリジン時のみ発生する」**

---

### 同一オリジンを実現する代表的な方法

1. フロント資産をバックエンドに同梱する（昔の構成）
2. Nginx / ALB で URL を統合する（現代の主流）
3. Next.js の route.ts を BFF として使う（一時的）

※ ③は短期解決策、①②が本命

---

## 2.0 同一オリジンとは何か（超重要概念）

### 同一オリジンの定義

**同一オリジン = 以下 3 要素がすべて一致していること**

```
① スキーム（http / https）
② ホスト（ドメイン or IP）
③ ポート番号
```

この 3 つのうち **1 つでも異なれば別オリジン** となる。

---

### 同一オリジン判定の具体例

| フロント                                       | API                                                    | 判定         |
| ---------------------------------------------- | ------------------------------------------------------ | ------------ |
| [http://localhost:3000](http://localhost:3000) | [http://localhost:3000/api](http://localhost:3000/api) | 同一オリジン |
| [http://localhost:3000](http://localhost:3000) | [http://localhost:8080/api](http://localhost:8080/api) | 別オリジン   |
| [http://example.com](http://example.com)       | [http://example.com/api](http://example.com/api)       | 同一オリジン |
| [https://example.com](https://example.com)     | [http://example.com/api](http://example.com/api)       | 別オリジン   |

---

### なぜブラウザは同一オリジンを要求するのか

- Cookie / Authorization ヘッダの漏洩防止
- 悪意あるサイトからの勝手な API 呼び出し防止
- **ブラウザがユーザーを守るための仕様**

※ curl / Postman / サーバ間通信ではこの制限は存在しない。

---

### 同一オリジンと CORS の関係

- 同一オリジン
  - CORS は **存在しない**
  - すべてのリクエストが自然に通る

- 別オリジン
  - ブラウザが CORS チェックを開始
  - サーバが許可ヘッダを返さないと通信不可

👉 **CORS は「別オリジン時のみ発生する」**

---

### 同一オリジンを実現する代表的な方法

1. フロント資産をバックエンドに同梱する（昔の構成）
2. Nginx / ALB で URL を統合する（現代の主流）
3. Next.js の route.ts を BFF として使う（一時的）

※ ③は短期解決策、①②が本命

---

## 2.1 CORS エラーとは何か

- **ブラウザが安全のために行う制御**
- サーバが拒否しているわけではない
- 「異なるオリジンへの Ajax 通信」をブラウザがブロックする

### オリジンの定義

```
オリジン = スキーム + ホスト + ポート
```

| URL                                            | 判定       |
| ---------------------------------------------- | ---------- |
| [http://localhost:3000](http://localhost:3000) | 同一       |
| [http://localhost:8080](http://localhost:8080) | 別オリジン |
| [http://example.com](http://example.com)       | 別オリジン |

※ **同一 EC2 上でもポートが違えば別オリジン**

---

## 2.2 なぜ route.ts では起きなかったか

- route.ts は Next.js と同一オリジン
- ブラウザから見ると

```
http://localhost:3000 → http://localhost:3000/api
```

- 完全に同一オリジンのため CORS が存在しない世界

---

## 2.3 route.ts を BFF として使うのはアンチパターンか

| 観点               | 評価 |
| ------------------ | ---- |
| ローカル開発       | ◎    |
| 認証情報の隠蔽     | ◎    |
| 本番運用           | △    |
| スケール・責務分離 | ✕    |

- **短期：OK**
- **中長期：インフラ側で吸収する設計に移行すべき**

---

# 3. バックエンド視点での理解

## 3.1 CORS 対応とは「何をする作業か」

- バックエンドが
  「このオリジンからのアクセスを許可する」
  と **HTTP ヘッダで明示**すること

### 代表的なレスポンスヘッダ

- Access-Control-Allow-Origin
- Access-Control-Allow-Methods
- Access-Control-Allow-Headers

### Spring Boot での実装箇所

- @CrossOrigin（Controller 単位）
- WebMvcConfigurer
- Spring Security の CORS 設定

※ **Spring Security が絡むと難易度が上がる**
（OPTIONS リクエストが弾かれやすい）

---

## 3.2 なぜ「昔は起きなかった」のか

### 昔の典型構成

```
Spring Boot
 ├─ /api/**
 └─ /static/** (HTML/JS)
```

- フロント資産をバックエンドに同梱
- 完全同一オリジン
- CORS 不要

→ **SPA 分離により初めて顕在化する問題**

---

# 4. Nginx / リバースプロキシの役割

## 4.1 Nginx の本質的役割

- リバースプロキシ（最重要）
- ポート隠蔽
- HTTPS 終端
- 内部構成の隠蔽

### ブラウザから見た構成

```
https://example.com
 ├─ /      → フロント
 └─ /api   → バックエンド
```

→ **実質的に同一オリジン**
→ CORS を意識しなくてよくなる

---

## 4.2 同一 EC2 でも CORS は起きるか

- 起きる
- **ポートが分かれていれば別オリジン**
- Nginx を入口に置かない限り解消しない

---

# 5. AWS マネージド環境での考え方

## 5.1 Nginx 的役割を担うもの

| 環境          | 入口の役割 |
| ------------- | ---------- |
| EC2 単体      | Nginx      |
| ECS / Fargate | ALB        |
| CDN           | CloudFront |

- ALB / CloudFront は **Nginx と同等の役割**
- OS レベルで Nginx を置く必要はない

---

## 5.2 ECS + ALB では Nginx は不要か

- 基本不要
- ALB がリバースプロキシを担当
- コンテナは内部ポートを意識すればよい

---

# 6. レイヤー別の責務整理（重要）

| レイヤー     | 例                       |
| ------------ | ------------------------ |
| ブラウザ     | CORS 判定・HTTP Cache    |
| フロント     | axios / fetch / 状態管理 |
| CDN          | CloudFront キャッシュ    |
| LB           | ALB                      |
| プロキシ     | Nginx                    |
| バックエンド | Spring Cache / DB        |

※ axios のキャッシュは **かなり低レイヤー**

---

# 7. 今回の現実的な解決方針

## 短期（ローカル検証）

- Spring Boot 側で CORS 許可
- localhost:3000 を明示

## 中期（検証・ステージング）

- ALB / Nginx で API を統合
- ポート直アクセスを廃止

## 長期（本番）

- CloudFront + ALB
- フロント / API を同一オリジン配信
- CORS 設定を極小化

---

# 8. 重要な結論

- CORS は「バグ」ではなく「設計の境界線」
- route.ts は一時的な安全地帯
- 最終的な正解は **入口（プロキシ / ALB）で統合**
- フロントとバックエンドの責務を正しく分けると迷わなくなる

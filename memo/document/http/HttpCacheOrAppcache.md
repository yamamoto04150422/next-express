# HTTPキャッシュとアプリキャッシュ 保存用まとめ

> テーマ別に整理し、背景・重要点・悩みどころが振り返れる構成

---

## 1. HTTPキャッシュとは何か（全体像）

### 背景

- ブラウザ / CDN / プロキシは **HTTP仕様に基づいて自動でキャッシュ** を行う
- フロントエンド開発者は「明示的に書かなくても効いている」ことが多い

### 重要点

- HTTPキャッシュは **通信最適化の仕組み**
- JavaScript・React・TanStack Query とは **完全に別レイヤ**

### あなたが悩んでいた点

- 「フロント側でどこに処理を書くのか？」
- 「axios / TanStack Query が関係するのか？」

➡ **結論：HTTPキャッシュはコードではなく HTTPヘッダで制御される**

---

## 2. Expiration Model（期限切れモデル）

### 概要

- 一定時間は **無条件でキャッシュを使う方式**

### 主なヘッダ

```http
Cache-Control: max-age=3600
Expires: Wed, 18 Dec 2025 10:00:00 GMT
```

### 動作イメージ

- キャッシュが「新鮮」な間は
  - ネットワーク通信なし
  - CDN / ブラウザが即レスポンス

### 使われる場面

- 静的ファイル（JS / CSS / 画像）
- 更新頻度が低いAPI

### 悩みポイント

- 「期限内に更新されたらどうする？」

➡ **期限内は更新されない前提で使う設計**

---

## 3. Validation Model（検証モデル）

### 概要

- キャッシュを使う前に **サーバーへ確認** する方式

### 主なヘッダ

```http
ETag: "abc123"
If-None-Match: "abc123"

Last-Modified: Tue, 17 Dec 2025 10:00:00 GMT
If-Modified-Since: Tue, 17 Dec 2025 10:00:00 GMT
```

### 動作イメージ

- サーバーが `304 Not Modified` を返す
- 本体データは返さず **転送量削減**

### 使われる場面

- APIレスポンス
- 「更新される可能性がある」データ

### 悩みポイント

- 「通信は発生するのに意味ある？」

➡ **通信量・レスポンスサイズが激減するため意味がある**

---

## 4. Heuristic Expiration（発見的期限切れ）

### 概要

- 明示的な期限が無い場合に
- ブラウザが **経験則で期限を決める**

### 例

- `Last-Modified` から推測
- 数分〜数時間で再検証

### 注意点

- **挙動がブラウザ依存**
- 予測不能

### 結論

- **APIでは使うべきではない**
- 明示的に `Cache-Control` を設定する

---

## 5. HTTPキャッシュとアプリキャッシュは別物

### HTTPキャッシュ

| 特徴   | 内容           |
| ------ | -------------- |
| レイヤ | ブラウザ / CDN |
| 制御   | HTTPヘッダ     |
| 目的   | 通信削減       |

### アプリキャッシュ（TanStack Queryなど）

| 特徴   | 内容                                   |
| ------ | -------------------------------------- |
| レイヤ | JavaScript                             |
| 制御   | ライブラリ設定（queryKey / staleTime） |
| 目的   | UI即時反映 / UX向上                    |

### あなたの混乱ポイント

- 「同一データなら通信は起きないのでは？」

➡ **アプリ内で同一でも HTTP通信は発生しうる**

---

## 6. アプリキャッシュの判断ロジック（重要）

### 判断材料

- **queryKey**：アプリ内で同一データかを判定
- **staleTime**：どれくらい新しいとみなすか

### 振る舞い

- 新しい場合 → **通信しない**
- 古い場合 → **通信するが UI は即表示**

```text
UI表示 →（裏で通信）→ 差し替え
```

➡ **通信の存在をUIから隠すのが目的**

---

## 7. HTTP通信はどこで最終判断されるか

```text
① アプリ（TanStack Query）
   ├ fetch を呼ぶか判断
   ↓
② ブラウザ / CDN（HTTPキャッシュ）
   ├ fresh → ネットワークに行かない
   └ stale → 条件付き or 通常通信
```

➡ **通信有無は最終的に HTTPヘッダで決まる**

---

## 8. フロントエンドは何を実装するのか

### 基本姿勢

- フロントは **HTTPヘッダを見て従うだけ**
- axios.ts にキャッシュ制御を書く必要はない

### TanStack Query の役割

```ts
useQuery({
  queryKey: ["users"],
  staleTime: 5 * 60 * 1000,
});
```

- HTTPキャッシュとは無関係
- UIレベルのキャッシュ制御

---

## 9. CDN効率化の正体

### よくある誤解

- 「フロントとバックエンドの通信最適化？」

### 実際

- CDNは **HTTPヘッダだけを見て判断**
- フロントの実装は関係ない

```text
Browser → CDN → Origin Server
        ↑ キャッシュヒット
```

---

## 10. Next.js が勝手にキャッシュする例（注意）

### デフォルト挙動

- App Router の `fetch` は自動キャッシュ

```ts
fetch("/api/data"); // キャッシュされる
```

### 無効化例

```ts
fetch("/api/data", { cache: "no-store" });
```

### 悩みポイント

- 「何もしてないのに古いデータが出る」

➡ **Next.js 内部キャッシュが原因**

---

## 11. 実務での使い分け指針（最終結論）

### 推奨構成

- 静的アセット → Expiration Model
- APIレスポンス → Validation Model
- UI状態 / 画面遷移 → アプリキャッシュ（TanStack Query）

### 覚える一文

> **HTTPキャッシュは通信最適化**
> **アプリキャッシュはUX最適化**
